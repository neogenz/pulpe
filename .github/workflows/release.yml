name: ğŸš€ Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Type of release"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  check-changes:
    name: ğŸ” Check for Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.changes.outputs.has-changes }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: ğŸ“¦ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Check for changes since last release
        id: changes
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Check if there are changes since the last tag
          CHANGES=$(git log --oneline ${LATEST_TAG}..HEAD --pretty=format:"%h %s" -- frontend/ backend-nest/ shared/ | wc -l)
          echo "Number of changes: $CHANGES"

          if [ $CHANGES -gt 0 ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“‹ Generate version
        id: version
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${LATEST_TAG#v}

          # Parse version components
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          # Determine release type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Auto-determine based on commit messages
            if git log ${LATEST_TAG}..HEAD --grep="BREAKING CHANGE" --oneline | grep -q .; then
              RELEASE_TYPE="major"
            elif git log ${LATEST_TAG}..HEAD --grep="feat" --oneline | grep -q .; then
              RELEASE_TYPE="minor"
            else
              RELEASE_TYPE="patch"
            fi
          fi

          # Calculate new version
          case $RELEASE_TYPE in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "version=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version will be: v$NEW_VERSION"

  release:
    name: ğŸ“¦ Create Release
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.has-changes == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ğŸ“¦ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“¦ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.12.1

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"

      - name: ğŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: ğŸ§ª Run full test suite
        run: |
          pnpm run build
          pnpm run test
          pnpm run lint

      - name: ğŸ“‹ Generate changelog
        id: changelog
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          NEW_VERSION="${{ needs.check-changes.outputs.version }}"

          echo "# ğŸ“‹ Changelog $NEW_VERSION" > TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md
          echo "## ğŸš€ Features" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="feat" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No new features" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md

          echo "## ğŸ› Bug Fixes" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="fix" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No bug fixes" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md

          echo "## ğŸ”§ Improvements" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="refactor\|perf\|style" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No improvements" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md

          echo "## ğŸ“š Documentation" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="docs" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No documentation changes" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md

          echo "## ğŸ§ª Tests" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="test" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No test changes" >> TEMP_CHANGELOG.md
          echo "" >> TEMP_CHANGELOG.md

          echo "## ğŸ”¨ Build & CI" >> TEMP_CHANGELOG.md
          git log ${LATEST_TAG}..HEAD --grep="ci\|build" --pretty=format:"- %s (%h)" >> TEMP_CHANGELOG.md || echo "- No build/CI changes" >> TEMP_CHANGELOG.md

      - name: ğŸ”¨ Build production artifacts
        run: |
          pnpm run build

          # Create release artifacts
          mkdir -p release-artifacts

          # Frontend artifacts
          if [ -d "frontend/dist" ]; then
            tar -czf release-artifacts/frontend-dist.tar.gz -C frontend dist/
          fi

          # Backend artifacts
          if [ -d "backend-nest/dist" ]; then
            tar -czf release-artifacts/backend-dist.tar.gz -C backend-nest dist/
          fi

          # Shared package
          if [ -d "shared/dist" ]; then
            tar -czf release-artifacts/shared-dist.tar.gz -C shared dist/
          fi

      - name: ğŸ·ï¸ Create Git tag
        run: |
          NEW_VERSION="${{ needs.check-changes.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $NEW_VERSION -m "Release $NEW_VERSION"
          git push origin $NEW_VERSION

      - name: ğŸš€ Create GitHub Release and Upload Assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read changelog
            const changelogContent = fs.readFileSync('TEMP_CHANGELOG.md', 'utf8');

            // Create release
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ needs.check-changes.outputs.version }}',
              name: 'Release ${{ needs.check-changes.outputs.version }}',
              body: changelogContent,
              draft: false,
              prerelease: false
            });

            // Upload artifacts if they exist
            const artifactsDir = './release-artifacts';
            if (fs.existsSync(artifactsDir)) {
              const files = fs.readdirSync(artifactsDir);
              for (const file of files) {
                const filePath = path.join(artifactsDir, file);
                const fileData = fs.readFileSync(filePath);
                
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id,
                  name: file,
                  data: fileData
                });
              }
            }

            // Create deployment issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ğŸš€ Deploy Release ${{ needs.check-changes.outputs.version }}',
              body: `
            ## ğŸš€ New Release Available

            **Version:** ${{ needs.check-changes.outputs.version }}
            **Release URL:** ${release.html_url}

            ### ğŸ“‹ Next Steps:
            - [ ] Review release notes
            - [ ] Deploy to staging environment
            - [ ] Run smoke tests
            - [ ] Deploy to production
            - [ ] Monitor metrics

            ### ğŸ”— Useful Links:
            - [Release Notes](${release.html_url})
            - [CI Build](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
              `,
              labels: ['deployment', 'release']
            });

  notify:
    name: ğŸ“¢ Notify Team
    runs-on: ubuntu-latest
    needs: [check-changes, release]
    if: always() && needs.release.result == 'success'
    steps:
      - name: ğŸ“¢ Post to Slack/Discord
        run: |
          echo "ğŸš€ Release ${{ needs.check-changes.outputs.version }} created successfully!"
          echo "Add your Slack/Discord webhook notification here"
