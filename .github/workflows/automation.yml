name: 🤖 Project Automation

on:
  issues:
    types: [opened, labeled, assigned]
  pull_request:
    types: [opened, synchronize, ready_for_review, closed]
  schedule:
    - cron: "0 9 * * 1" # Every Monday at 9 AM

jobs:
  auto-label-issues:
    name: 🏷️ Auto Label Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: 🏷️ Label based on issue content
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body.toLowerCase();

            const labels = [];

            // Auto-detect issue type
            if (title.includes('bug') || body.includes('error') || body.includes('broken')) {
              labels.push('bug');
            }
            if (title.includes('feature') || title.includes('enhancement')) {
              labels.push('enhancement');
            }
            if (title.includes('doc') || body.includes('documentation')) {
              labels.push('documentation');
            }
            if (title.includes('performance') || body.includes('slow')) {
              labels.push('performance');
            }

            // Auto-detect component
            if (body.includes('frontend') || body.includes('angular')) {
              labels.push('frontend');
            }
            if (body.includes('backend') || body.includes('nestjs') || body.includes('api')) {
              labels.push('backend');
            }
            if (body.includes('shared') || body.includes('types')) {
              labels.push('shared');
            }

            // Priority detection
            if (title.includes('urgent') || body.includes('critical')) {
              labels.push('priority:high');
            } else if (title.includes('minor')) {
              labels.push('priority:low');
            } else {
              labels.push('priority:medium');
            }

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

  auto-assign-reviewers:
    name: 👥 Auto Assign Reviewers
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: 📦 Checkout
        uses: actions/checkout@v4

      - name: 🔍 Detect changed files
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend-nest/**'
            shared:
              - 'shared/**'
            docs:
              - '*.md'
              - 'docs/**'

      - name: 👥 Assign reviewers based on changes
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const reviewers = [];
            const labels = [];

            // Add labels based on changed files
            if ('${{ steps.changes.outputs.frontend }}' === 'true') {
              labels.push('frontend');
              // Add frontend reviewers here
            }
            if ('${{ steps.changes.outputs.backend }}' === 'true') {
              labels.push('backend');
              // Add backend reviewers here
            }
            if ('${{ steps.changes.outputs.shared }}' === 'true') {
              labels.push('shared');
            }
            if ('${{ steps.changes.outputs.docs }}' === 'true') {
              labels.push('documentation');
            }

            // Add size label
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalChanges = additions + deletions;

            if (totalChanges < 50) {
              labels.push('size:small');
            } else if (totalChanges < 200) {
              labels.push('size:medium');
            } else {
              labels.push('size:large');
            }

            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
            }

  stale-issues:
    name: 🧹 Manage Stale Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: 🧹 Mark stale issues
        uses: actions/stale@v9
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          stale-issue-message: |
            👋 Cette issue semble inactive depuis un moment.

            Si elle est toujours d'actualité, n'hésitez pas à la commenter pour la réactiver.
            Sinon, elle sera fermée automatiquement dans 7 jours.
          stale-pr-message: |
            👋 Cette PR semble inactive depuis un moment.

            Merci de la mettre à jour ou de donner des nouvelles.
            Sinon, elle sera fermée automatiquement dans 7 jours.
          stale-issue-label: "stale"
          stale-pr-label: "stale"
          days-before-stale: 30
          days-before-close: 7
          exempt-issue-labels: "pinned,security,enhancement"
          exempt-pr-labels: "pinned,security"

  weekly-report:
    name: 📊 Weekly Project Report
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: 📊 Generate project metrics
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              since: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
            });

            const openIssues = issues.filter(issue => !issue.pull_request && issue.state === 'open').length;
            const closedIssues = issues.filter(issue => !issue.pull_request && issue.state === 'closed').length;
            const openPRs = issues.filter(issue => issue.pull_request && issue.state === 'open').length;
            const mergedPRs = issues.filter(issue => issue.pull_request && issue.state === 'closed').length;

            const report = `
            # 📊 Rapport Hebdomadaire - ${new Date().toLocaleDateString('fr-FR')}

            ## 📈 Métriques de la semaine
            - **Issues ouvertes**: ${openIssues}
            - **Issues fermées**: ${closedIssues}
            - **Pull Requests ouvertes**: ${openPRs}
            - **Pull Requests mergées**: ${mergedPRs}

            ## 🎯 Objectifs de la semaine prochaine
            - [ ] Réduire le nombre d'issues ouvertes
            - [ ] Maintenir la qualité du code
            - [ ] Améliorer la couverture de tests

            ---
            *Rapport généré automatiquement par GitHub Actions*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `📊 Rapport Hebdomadaire - ${new Date().toLocaleDateString('fr-FR')}`,
              body: report,
              labels: ['report', 'weekly']
            });

  pr-size-warning:
    name: ⚠️ PR Size Warning
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'synchronize')
    steps:
      - name: ⚠️ Check PR size and warn if too large
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const totalChanges = (pr.additions || 0) + (pr.deletions || 0);

            if (totalChanges > 500) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `
            ## ⚠️ Grande Pull Request Détectée

            Cette PR contient **${totalChanges} modifications** ce qui peut rendre la review difficile.

            ### 💡 Suggestions:
            - Diviser en plusieurs PRs plus petites
            - S'assurer que les tests passent
            - Fournir une description détaillée
            - Considérer une review par étapes

            ### 📋 Checklist avant merge:
            - [ ] Tests unitaires ✅
            - [ ] Tests d'intégration ✅
            - [ ] Review approfondie ✅
            - [ ] Documentation mise à jour ✅
                `
              });
            }
